<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>메인 페이지</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            list-style: none;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            padding: 50px;
            gap: 10px;
        }

        ul {
            border: 1px solid #000;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            transition: .3s;
        }
        li {
            width: 200px;
            height: 60px;
            border: 1px solid #ccc;
            display: flex;
            justify-content: center;
            align-items: center;

            /* transition: .2s; */
            /* transition: transform 100ms ease 0s; */
            /* transform: translate3d(0px, 0px, 0px); */
        }
        li.dragging {
            /* opacity: .9; */
            box-shadow: 0px 0px 1px 1px rgb(181, 234, 255);
            border: 1px solid rgb(216, 216, 255);
            background: rgb(239, 249, 255);
            /* cursor: grabbing; */
        }
        li.dragAni:not(.dragging) {
            animation: dragAni .15s;
            /* translate: 0 -30%;
            transition: .1s; */
            /* transition: .1s cubic-bezier(.5, -1.5, .5, 1.5); */
        }
        li.dragAniTop:not(.dragging) {
            animation: dragAniTop .15s;
            /* translate: 0 30%;
            transition: .1s; */
            /* transition: .1s cubic-bezier(.5, -1.5, .5, 1.5); */
        }
        @keyframes dragAni {
            0% {translate: 0 -30%;}
            /* 50% {translate: 0 7%;} */
            100% {translate: 0 10%;}
        }
        @keyframes dragAniTop {
            0% {translate: 0 30%;}
            /* 50% {translate: 0 -7%;} */
            100% {translate: 0 -10%;}
        }

        li.slideT {animation: slideT .2s;}
        @keyframes slideT {100% {translate: 0 -100%;}}
        li.slideB {animation: slideB .2s;}
        @keyframes slideB {100% {translate: 0 100%;}}
        li.slideL {animation: slideL .2s;}
        @keyframes slideL {100% {translate: 100% 0;}}
        li.slideR {animation: slideR .2s;}
        @keyframes slideR {100% {translate: -100% 0;}}
    </style>
</head>
<body id="body">
    <ul class="container" id="A">
        <li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
        <li>5</li>
    </ul>
    <ul class="container" id="B">
        <li>a</li>
        <li>b</li>
        <li>c</li>
        <li>d</li>
        <li>e</li>
    </ul>
</body>
<script>
    const dragAndDrop = (listWrap, list, option) => {

        const optionDefault = {
            verticalDirection: true,
            simpleVersion: true,
            dropEvent: () => {},
            changeEvent: () => {},
        }
        option = {
            ...optionDefault,
            ...option
        }

        const id = `customId_No${Math.floor(Math.random() * 10e5)}`
        document.head.insertAdjacentHTML("beforeend", `<style>
        </style>`)
        document.body.insertAdjacentHTML("afterbegin", `
        `)

        const customWrap = document.querySelector("body")
        const modalCustom = customWrap.querySelector(`#${id}`)

        const listWrapArray = document.querySelectorAll(listWrap)
        const listArray = document.querySelectorAll(listWrap + (list ?? " > *"))

        const getElement = (ul, cursor) => {
            const liArray = [...ul.querySelectorAll("li:not(.dragging)")]
            const pointArray = liArray.map(li => {
                const rect = li.getBoundingClientRect()
                return option.verticalDirection ? (rect.y + rect.height / 2) : (rect.x + rect.width / 2)
            })
            for(const [index, item] of pointArray.entries()) {
                if(item > cursor[option.verticalDirection ? "y" : "x"]) return liArray[index]
            }
            return false
        }
        
        // let beforeIndex

        // let beforeElement
        listArray.forEach((li, i) => {
            li.setAttribute("draggable", true)
            li.addEventListener("dragstart", e => {
                li.classList.add("dragging")
                // ul.querySelectorAll(list).forEach((e, i) => {
                //     if()
                // })
                // beforeIndex = i
                // li.style.position = "fixed"
                // li.style.top = e.y
                // li.style.left = e.x
                // beforeElement = li.nextElementSibling
            })
            li.addEventListener("dragend", e => {
                li.classList.remove("dragging")
                // li.style.position = "initial"
            })
            li.addEventListener("drop", e => option.dropEvent(e))
            // e.addEventListener("dragenter", () => {})
        })

        let swap = false
        listWrapArray.forEach(ul => {
            ul.addEventListener("dragover", e => {
                e.preventDefault()
                const element = getElement(ul, e)
                const now = document.querySelector(".dragging")

                const prevE = element ? element.previousElementSibling : ul.querySelector((list ?? "&>*") + ":last-child")

                if(prevE == now) return
                else if(swap) return
                // const nextRect = element && element.getBoundingClientRect()
                // const prevRect = (element ? element.previousElementSibling : ul.querySelector("&>*:last-child")).getBoundingClientRect()
                // const direction = (element === false || (nextRect.y + nextRect.height / 2) > e.y) ? "F" : (e.y > (prevRect.y + prevRect.height / 2) ? "B" : false)


                
                const nowWrap = now.closest(listWrap)
                const elementWrap = document.elementFromPoint(e.x, e.y).closest(listWrap)
                // const elementWrap = element.closest(listWrap)
                if(nowWrap != elementWrap) {
                    
                    const move = () => {
                        // now.classList.remove("slideL", "slideR")
                        now.style.transition = 0
                        now.style.transform = "none"
                        element === false ? elementWrap.appendChild(now) : element.before(now)
                        option.changeEvent(e)
                        // now.removeEventListener("animationend", move)
                        // now.removeEventListener("transitionend", move)
                        swap = false
                    }

                    const ghost = document.createElement(now.tagName)
                    ghost.style.opacity = 0
                    elementWrap.appendChild(ghost)

                    // let nextWrapElement = element
                    // while(nextWrapElement) {
                    //     nextWrapElement.classList.add("slideB")
                    //     // nextWrapElement.addEventListener("animationend", animationend)
                    //     setTimeout(() => nextWrapElement.classList.remove("slideB"), 200)
                    //     nextWrapElement = element.nextElementSibling
                    // }
                    let elementTrigger = false;
                    [...elementWrap.querySelectorAll(list ?? "&>*")].forEach(e => {
                        if(e == element) elementTrigger = true
                        if(elementTrigger) e.classList.add("slideB") ?? setTimeout(() => e.classList.remove("slideB") ?? ghost.remove(), 200)   
                    })

                    swap = true
                    // now.classList.add(nowWrap.getBoundingClientRect().x > elementWrap.getBoundingClientRect().x ? "slideR" : "slideL")
                    now.style.transition = "0.2s"
                    const elementRect = element ? element.getBoundingClientRect() : elementWrap
                    const nowRect = now.getBoundingClientRect()
                    now.style.transform = `translate(${elementRect.x - nowRect.x}px, ${elementRect.y - nowRect.y}px)`
                    // now.addEventListener("animationend", move)
                    // now.addEventListener("transitionend", move)
                    setTimeout(move, 200)
                }


                
                const nowRect = now.getBoundingClientRect()
                const nowY = nowRect.y + nowRect.height / 2
                const direction = e.y > nowY
                // const direction = nowY > e.y + now.getBoundingClientRect().height
                if(now.getBoundingClientRect().height / 2 > Math.abs(nowY - e.y)) return

                
                // if(beforeElement == element) return
                // beforeElement = element

                
                // const prevE = now.previousElementSibling
                // const nextE = now.nextElementSibling
                
                // let prevTempE = element.previousElementSibling
                // while(prevTempE) {
                //     if(!prevTempE.classList.contains("dragging")) {
                //         prevE = prevTempE
                //         prevTempE = 0
                //     } else prevTempE = prevTempE.previousElementSibling
                // }

                // const direction = (element === false || (element.getBoundingClientRect().y + element.getBoundingClientRect().height / 2) > e.y) ? "F" : (prevE.getBoundingClientRect().y > e.y ? "B" : false)
                // const direction = (element === false || (nextRect.y + nextRect.height / 2) > e.y) ? "F" : (e.y > (prevRext.y + prevRext.height / 2) ? "B" : false)


                // if(element === false) ul.appendChild(now)
                // else element.before(now)

                // const nowIndex = [...ul.querySelectorAll(list ?? "*")].findIndex(e => e == element) - 1
                // const direction = nowIndex > beforeIndex

                // const direction = element && element.getBoundingClientRect().y > e.y
                
                    // element.previousElementSibling.style.transition = 0
                    // element.previousElementSibling.style.translate = 0
                    // listArray.forEach(e => {
                    //     e.style.transition = 0
                    //     e.style.translate = 0
                    // })

                const slide = () => {
                    // now.nextElementSibling.style.transition = 0
                    // now.style.transition = 0
                    // now.nextElementSibling.style.translate = 0
                    // now.style.translate = 0

                    // now.classList.remove("slideB", "slideT")
                    // now.previousElementSibling.classList.remove("slideB", "slideT")
                    // now.nextElementSibling.classList.remove("slideB", "slideT")
                    // direction ? now.nextElementSibling.after(now) : now.previousElementSibling.before(now)
                    if(direction && now.nextElementSibling) {
                        now.classList.remove("slideB")
                        now.nextElementSibling.classList.remove("slideT")
                        now.nextElementSibling.after(now)
                    } else if(now.previousElementSibling) {
                        now.classList.remove("slideT")
                        now.previousElementSibling.classList.remove("slideB")
                        now.previousElementSibling.before(now)
                    }
                    option.changeEvent(e)
                    now.removeEventListener("animationend", slide)
                    swap = false
                }
                swap = true
                if(direction && now.nextElementSibling) {
                    // element.after(now)
                    // element.style.transition = 0
                    // element.style.translate = 0
                    // now.style.transition = 0
                    // now.style.translate = 0
                    // now.nextElementSibling.style.transition = ".2s"
                    // now.style.transition = ".2s"
                    // now.nextElementSibling.style.translate = "0 -100%"
                    // now.style.translate = "0 100%"
                    now.nextElementSibling.classList.add("slideT")
                    now.classList.add("slideB")

                    // transitionend
                } else if(now.previousElementSibling) {
                    // element.previousElementSibling && (element.previousElementSibling.style.translate = "0 100%")
                    now.previousElementSibling.classList.add("slideB")
                    now.classList.add("slideT")
                }
                // now.addEventListener("animationend", slide)
                setTimeout(slide, 200)

                // beforeIndex = nowIndex

                // const setClass = (element, className, index) => {
                //     element.classList.add(className)
                //     element.style.animationDelay = index * 0.05 + "s"
                //     const deleteDragAni = () => {
                //         element.classList.remove(className)
                //         element.removeEventListener("transitionend", deleteDragAni)
                //         element.removeEventListener("animationend", deleteDragAni)
                //     }
                //     element.addEventListener("transitionend", deleteDragAni)
                //     element.addEventListener("animationend", deleteDragAni)
                // }
                // let sibling = now.nextElementSibling
                // let siblingCount = 0
                // while(sibling) {
                //     setClass(sibling, "dragAni", siblingCount++)
                //     sibling = sibling.nextElementSibling
                // }
                // sibling = now.previousElementSibling
                // siblingCount = 0
                // while(sibling) {
                //     setClass(sibling, "dragAniTop", siblingCount++)
                //     sibling = sibling.previousElementSibling
                // }
            })
        })
    }

    dragAndDrop("ul.container")
</script>
</html>